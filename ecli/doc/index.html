<HTML>
<HEAD><TITLE>ECLI - Eiffel Wrapper for the ISO/CLI DBMS Interface</TITLE>
</HEAD>

<BODY>

<PRE>
Eiffel Library to ISO/CLI (Call Level Interface) comptabile DB systems

Author : Paul G. Crismer <pgcrism@attglobal.net>
License: Released under the Eiffel Forum License
Copyright: 2000 - Paul G. Crismer
</PRE>

<H1>Table of contents</H1>
<PRE>
	<em>Abstract</em>
	<em>Section</em> 0 : Current Status
	<em>Section</em> 1 : Design choices
	<em>Section</em> 2 : Implementation notes
	<em>Section</em> 3 : Architecture Diagram
	<em>Section</em> 4 : TODO
</PRE>
<H1>Abstract</H1>

<PRE>
	ECLI is an Eiffel wrapper around the X/Open ISO/CLI (Call Level Interface).
This interfaces defines an API to RDBMS drivers, and uses SQL92.
ISO/CLI is also known as ODBC under MS-Windows.  This interface has implementations on other platforms.

ECLI wants to be portable across (1) Platforms, (2) Eiffel Compilers.

(1) Platform portability : ECLI works on any platform that has an ISO/CLI Implementation.

(2) Eiffel Compiler Portability : ECLI uses as "standard" Eiffel as possible.
The GOBO Library is used for specific data structures.

Some tricks have been used to be free from the idiosyncrasies of any Eiffel Compiler.
It is a pity that even for basic/kernel classes it seems impossible for compiler vendors/providers to
agree on some standard.
</PRE>

<H1>Section 0 : Current Status</H1>

<PRE>
	Simple Database access :
1) Connect/Disconnect to a database
2) Issue SQL Statements
	with or without parameters
3) Get result set data.

For the moment, only CHAR, VARCHAR, INTEGER, FLOAT, DOUBLE, DATE and TIMESTAMP data are supported.

Since databases can convert automatically CHAR values to other SQL data types, it is possible
to use ECLI in the current state of development for common RDBMS access.

	Compiler portability :
* ISE Eiffel
* SmallEiffel

	Platforms :
* Windows
( Linux to come ...)

</PRE>

<H1>Section 1 : Design choices</H1>

<H2>D1. Rationale</H2>
<PRE>
	The X/Open Call Level Interface is a standard API for database access.
It is available on various platforms, i.e. Unix, Linux, Win32.  This is one of the
only standards that all vendors, including M$, fully support without "modifying" it.
</PRE>
<H2>D2. Simplicity</H2>
<PRE>
	This Eiffel interface is close to CLI, and hides some implementation details as
well.  This is a very simple wrapper.

The main goal is to give a clear and simple database access for common applications.
Since it is a thin wrapper, performance should be as good as possible.
</PRE>
<H2>D3. What it is not</H2>
<PRE>
	It is not an OO-to-Relational wrapper framework.  This interface can be a component
of such a framework
</PRE>
<H1>Section 2 : Implementation notes</H1>

<H2>I1. Transactions</H2>
<PRE>
	CLI allows only one transaction per connection/session.  There is no subtransaction
mechanism.
</PRE>
<H2>I2. Error diagnostic</H2>
<PRE>
	Class ECLI_STATUS implements the necessary mechanisms.
</PRE>
<H2>I3. Data transfer between Database and Program space</H2>
<PRE>
	Modules that transfer data between database and program space should know the
database data type and the program data type.  That is why data-transfer-values are encapsulated
in the class ECLI_VALUE and its descendants.
Descendant classes map CLI specific database values : CHAR, VARCHAR, INTEGER, ...
</PRE>
<H1>Section 3 : Architecture Diagram</H1>
<img src="./architecture.jpg">
<H1>Section 4 : TODO</H1>
<PRE>
T0. Implement other data values : Time, LONGVARCHAR, BINARY, LONGVARBINARY, ...
Those data values should serve
for data transfer, not as implementation of corresponding Abstract Data Types.
ADT should be defined as clients or extension by inheritance.

T1. Documentation.

T2. Long Variable Data (LONGVARCHAR, LONGVARBINARY) : Result set columns currently are retrieved
one column at a time (using SQLGetData).  Very long data cannot be stored in computer memory.
Those ECLI_LONGVARCHAR and ECLI_LONGVARBINARY classes should provide an interface that allows
reading/writing data to a file. For example, 'item' would be of FILE type.

T3. Test cases

T4. Examples

T5. Port to Unix/Linux.  This should be fairly easy using UnixODBC : www.unixodbc.org

T6. Getting various metadata : Result-set metadata, Tables/Columns/Indexes catalog metadata,
SQL Datatypes metadata.

T7. Refactoring ... Make better use of inheritance, if possible.

T8. Allow Bulk data transfers : a cursor is not a single line, but an array of lines.  This is interesting for
performance reasons. (Nice to have).
</PRE>
</BODY>
</HTML>