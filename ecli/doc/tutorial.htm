<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="Version" content="8.0.3410">
  <meta name="Date" content="10/11/96">
  <title>ECLI Tutorial</title>
  <style type="text/css">
  	body {color: black; background: white;
  		font-family: Verdana, sans-serif;
  		font-size: 10pt;
		margin-left: 5%;
		margin-right: 5%;
  	}
  	td {
  		font-family: Verdana, sans-serif;
  		font-size: 10pt;
	}
	table {
		margin-left: 5%;
		margin-right: 5%;
	}
  	h1 {  		font-family: Verdana, sans-serif;
				font-weight: bold; font-size: 16pt;}
  	h2 {  		font-family: Verdana, sans-serif;
				font-weight: bold; font-size: 13pt;}
	h3 {  		font-family: Verdana, sans-serif;
				font-weight: bold; font-size: 11pt;}
  	#title p {
  		text-align: center;}
  	#title .title {font-size: 200%; font-weight: bold;}
  	#title .author {font-size: 150%; font-weight: bold;}
	#toc {
		background: rgb(204,204,255);
		padding: 0.5em;
		border: none;
		margin-left: 10%;
		margin-right: 10%;
	  }
	#code {
		background: rgb(255,255,204);
		padding: 0.5em;
		border: none;
		font-family: courier, serif;
		font-size: 10pt;
		margin-left: 10%;
		margin-right: 10%;
	}
  </style>
</head>
 <body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#800080">

<div id="title">
	<p class="title">ECLI Tutorial</p>
	<p class="author">Paul G. Crismer</p>
	<p class="email">pgcrism @ users.sourceforge.net</p>
	<pre>$Date: 2003/02/25 09:23:00 $</pre>
	<pre>$Revision: 1.13 $</pre>
</div>
<div id="toc">
<ol>
  <li><a href="#Introduction">Introduction</a>
     </li>
  <li><a href="#ODBCCLI">ODBC/CLI Background</a></li>
  <li><a href="#Yourfirstdatabase">Your first database session</a></li>
  <li><a href="#Statuscheckinganderror">Status checking and error handling</a></li>
  <li><a href="#StatementExec">Statement execution</a></li>
  <li><a href="#GettingResults">Getting results</a></li>
  <li><a href="#Getting%20esult-setmetadata">Getting result-set metadata</a></li>
  <li><a href="#Stored_procedures">Stored Procedures</a></li>
  <li><a href="#Transactions">Transactions</a></li>
  <li><a href="#ParameterizedStmts">Parameterized statements</a></li>
  <li><a href="#Tracing_">Tracing</a></li>
  <li><a href="#OptimizingforPerformance">Optimizing for "performance"</a></li>
  <li><a href="#Conclusion">Conclusion</a></li>
</ol>
</div>
<h1><a name="Introduction"></a>
   Introduction</h1>

<h2>What is ECLI ?</h2>

<p>Eiffel Call Level Interface (aka ECLI) is an Eiffel wrapper of the CLI (Call Level Interface).
CLI is a specification and standard for relational SQL database API:
<ul><li>The X/Open CAE specification Data Management: SQL Call-Level Interface (CLI)</li>
<li>ISO/IEC 9075-3:1995 (E) Call-Level Interface (SQL/CLI)</li></ul>

    This interfaces defines an abstract API on top of RDBMS drivers, and uses SQL92.
    This interface has implementations on MS-Windows (ODBC - Open DataBase Connectivity) and on other platforms like Unix and Linux.</p>

<p>&nbsp;Recommended readings : </p>

<ul>
  <li><a href="index.html">ECLI presentation</a></li>

  <li><a href="http://www.unixodbc.org/">UnixODBC</a> provides information about ODBC and its Unix/Linux implementation.</li>
</ul>

<h2>Why use ECLI ?</h2>

<p>If you want a simple access to relational databases, ECLI is for you. It
allows writing Eiffel database applications that have the following characteristics
 : &nbsp;</p>

<DL>
	<DT><b>Multiplatform</b></DT><DD>it uses a standard API,
available  on various platforms : Windows, Unix, Linux</DD>
	<DT><b>Multicompiler</b></DT><DD>it uses as portable Eiffel   as
possible, and has already been tested using
		<UL>
			<LI>ISE Eiffel and</LI>
			<LI>SmartEiffel </LI>
			<LI>VE 3.2. ** WARNING : On Win32 use external Microsoft Linker;
default VE linker leads to execution errors **</LI>

		</DD>
</DL>


<p>It currently has been tested with the following RDBMS drivers : MS-Access,
 Oracle 8, Oracle 8i, PostgreSQL, Interbase61, SQL Server.<p>
<p>It has been built and run with the following
OSes : Win98, WIN NT4, Windows 2000, Caldera Linux 2.3, Suse Linux, Debian Linux. </p>

<h2>Related work</h2>

<p align="Left">Many vendor specific libraries exist. Open-source libraries
 exist and are either compiler-specific or platform-specific. The best known
 are presented in the following table : &nbsp; </p>

<table width="80%" border="1" cellpadding="3" cellspacing="0">
 		<tr>
 			<td valign="Top" width="20%"><b>Product</b> </td>
            <td valign="Top" width="20%"><b>Vendor</b> </td>
            <td valign="Top" width="20%"><b>Compiler</b> </td>
            <td valign="Top" width="20%"><b>Platform</b> </td>
            <td valign="Top" width="20%"><b>RDBMS</b> </td>
		</tr>
        <tr>
            <td>EiffelStore</td>
            <td>ISE</td>
            <td>ISE</td>
            <td>Windows (ODBC), some Unixes</td>
            <td>ODBC, Oracle, Informix</td>
        </tr>
        <tr>
            <td>ISS-Store</td>
            <td>Halstenbach</td>
            <td>ISS-bench</td>
            <td>Windows, (Unix ?)</td>
            <td>ODBC</td>
        </tr>
        <tr>
            <td>DALE</td>
            <td>Object-Tools</td>
            <td>Visual Eiffel</td>
            <td>Windows, (Linux ?)</td>
            <td>ODBC</td>
        </tr>
        <tr>
            <td>pgsql</td>
            <td>Open Source</td>
            <td>SmallEiffel</td>
            <td>Unix, Linux, (Windows?)</td>
            <td>PostgreSQL</td>
        </tr>
</table>

<p>Other database bindings exist : see in the <a href="http://www.eiffel-forum.org/">
   Eiffel Forum</a>
   . </p>

<p>None of them is truly multi-compiler and multi-platform. Many target only
 one RDBMS system like MySQL, mSQL or PostgreSQL. </p>

<p>The originality of ECLI is that it uses a standardized API as underlying
 layer, and that it is designed to be as multi-compiler as possible. </p>

<h2>About this tutorial</h2>

<p>This tutorial introduces the basics of using ECLI. It is not a tutorial
 on Relational Database modeling, nor on RDBMS systems management. </p>

<p>We assume that the reader has at least basic knowledge in database applications
 and is familiar with relational databases and SQL. </p>

<h1><a name="ODBCCLI"></a>
   ODBC/CLI Background</h1>

<h2>Layers</h2>

<p>ODBC/CLI applications have 3 layers </p>

<ol>

  <li>Application</li>

  <li>Driver Management</li>

  <li>Driver</li>

</ol>

<p align="Center">You provide the first layer. The second and third layers
 are provided by ODBC/CLI run-time and configuration. </p>

<p align="Center"><img src="Image1.gif" width="391" height="257">
    </p>

<h2>Data Source</h2>

<p>When you want to access a specific database, you have to provide some configuration
information </p>

<ul>

  <li>A driver</li>

  <li>A host-name or file-name</li>

  <li>A port number</li>

  <li>Some authorization information</li>

</ul>

<div align="Left">ODBC/CLI associates a name with a set of configuration information.
This is known as the <i>data source name</i>. ODBC/CLI configuration is generally
stored in a file : <tt>ODBC.INI</tt>.</div>
<p align="Center"></p>

<div align="Center">
<center>
<table width="80%" border="1" cellpadding="5" cellspacing="0">
       <tr>
            <td valign="Top" width="50%"><b>Data source name</b> </td>
            <td valign="Top" width="50%"><b>Driver + parameters</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="50%">Students</td>
            <td valign="Top" width="50%">Access (msjet.dll);         file=X:\AccessDB\Students.mdb</td>
        </tr>
        <tr>
            <td valign="Top" width="50%">Library</td>
            <td valign="Top" width="50%">PostgreSQL Driver         (/usr/local/bin/pgsql.so);
 port=8032;         host="Titan"</td>
        </tr>
        <tr>
            <td valign="Top" width="50%">Oracle Test</td>
            <td valign="Top" width="50%">Oracle         (D:\ORANT\WIN32\oraodbc.dll);
 database=otst01;         rowprefetch=20</td>
        </tr>
</table>
    </center>
   </div>

<p align="Center">The above table shows some sample data source configurations.<br>
</p>
<div align="Left">
<h2>SQL Syntax</h2>
CLI/ODBC defines a "standard" SQL syntax, which is a subset of the SQL-92
standard.
<h3>Data Definition Language : create an maintain database schema.</h3>
Table creation follows a standard pattern. &nbsp;<br>
<br>
Do not expect any standard about datatypes. &nbsp;Even if they have the same
name across databases, they are effectively "nearly the same".<br>
There is no standard syntax about index creation, table structure modification,
or stored procedure definition.<br>
<br>
If you want to create projects that run on several databases, expect to define
as many DDL batches as there are database targets.<br>
Advise : put those DLL statements in text files that you select at run-time,
depending on the type of database you use.
<h3>Data Manipulation Language : select, insert and update data.</h3>
There is a "minimum" syntax that you can expect to be standard.<br>
Only special operations like outer joins need some further scrutiny.
<h3>Escape sequences</h3>
Some escape sequences have been defined in ODBC to express things in a database-neutral
way :<br>
<ol>
  <li>Date, time, timestamp literals</li>
  <li>Stored Procedure calls</li>
  <li>Scalar functions</li>
</ol>
** Warning : database drivers can implement a subset of escape sequences**<br>
Always check for what they implement before developing your applications.<br>
<table width="80%" cellpadding="5" cellspacing="0" border="1">

    <tr>
      <td valign="Top" width="320"><b>Escape sequence</b><b><br>
      </b></td>
      <td valign="Top"><b>Description</b><br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><i><b>Literals</b></i><br>
      </td>
      <td valign="Top"><i>If the database implements the associated datatype,
it also understands the escape sequence for the literal.</i><br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b>{t '</b><i>hh</i><i>:</i><i>mm:ss</i>[<i>.nnn</i>
]<b>'}</b><br>
      </td>
      <td valign="Top">Time literal. &nbsp;The optional .nnn part, expresses
a fractional part <u><i>up to</i></u> a nanosecond precision. <i><u>REMARK:</u><b>
 </b><br>
Not all databases can bear the same precision (database-dependent)</i>.<br>
      <b>Advice</b> : if portability is necessary, consider <b>no</b> fractional
part.<br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b>{d '</b><i>yyyy-mm-dd</i><b>'}</b><br>
      </td>
      <td valign="Top">Date literal<br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b>{ts '</b><i>yyyy-mm-dd hh:mm:ss</i>[<i>.nnn</i>
]<b>'}</b><br>
      </td>
      <td valign="Top">Timestamp literal. &nbsp;Same<u> remark</u> as for
time literal.<br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b><i>Stored Procedure calls</i></b><br>
      </td>
      <td valign="Top"><br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b>{call</b> <i>procedure_name</i> [ <b>(</b><i>parameter_list</i><b>
)</b> ]<b> }</b><br>
      </td>
      <td valign="Top">Procedures are not supported by databases. Procedure
calls are not supported by all drivers.<br>
Check before using them.<br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><i><b>Scalar functions</b></i><br>
      </td>
      <td valign="Top"><br>
      </td>
    </tr>
    <tr>
      <td valign="Top"><b>{fn</b> scalar-function<b>}</b><br>
      </td>
      <td valign="Top">The complete list of scalar functions supported is
driver dependent.<br>
There are string, &nbsp;numeric, time , date, system, datatype conversion
functions.<br>
Please refer to <a href="http://msdn.microsoft.com/library/en-us/odbc/htm/odbcscalar_functions.asp">
appendix E</a>
 of <a href="http://msdn.microsoft.com/library/en-us/odbc/htm/dasdkodbcoverview.asp">
ODBC reference manual</a>
 .<br>
      <br>
      </td>
    </tr>

</table>
<br>
</div>
<p align="Center">  </p>

<h1><a name="Yourfirstdatabase"></a>
 Your first database session</h1>

<p align="Left">The class ECLI_SESSION provides session-management features.
 A session object is created for accessing a specific <i>data-source</i>,
by using authorization rights of a specific database <i>user</i>. &nbsp; </p>

<div id="code">
<pre>
session : ECLI_SESSION
data_source_name , user_name, password : STRING

...

-- create session object
create session.<b>make</b> (data_source_name, user_name, password)

-- actual connection
session.connect

-- verify everything is ok
if session.<b>is_connected</b> then
	do_session
else
	handle_error (session)
end
session.<b>disconnect</b>
session.<b>close</b>
<pre>

</pre>
</div>

<p>ECLI_SESSION features introduced so far : <br>
</p>

<table width="80%" border="1" cellpadding="5" cellspacing="0">

       <tr>
            <td valign="Top" width="50%"><b>Command</b> </td>
            <td valign="Top" width="50%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>make</i></td>
            <td valign="Top" width="50%">creation</td>
        </tr>
        <tr>
            <td><em>open</em></td>
            <td>open a new database (synonym of make)</td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>connect</i></td>
            <td valign="Top" width="50%">actual connection to         database</td>
        </tr>
        <tr>
            <td><em>disconnect</em></td>
            <td>disconnect from database</td>
        </tr>
        <tr>
            <td><em>close</em></td>
            <td>be ready for a new opening</td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><b>Queries</b> </td>
            <td valign="Top" width="50%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>is_connected</i></td>
            <td valign="Top" width="50%">is the session connected ?</td>
        </tr>


</table>

<h1><a name="Statuscheckinganderror"></a>
   Status checking and error handling</h1>

<p>All sensible ECLI classes inherit from the ECLI_STATUS class, which provides
 status checking and error handling. </p>

<p>Standard ODBC error handling information provides : <br>
</p>

<table width="80%" border="0" cellpadding="3" cellspacing="0">
       <tr>
            <td valign="Top" width="29%">
      <ul>
        <li>State&nbsp;</li>
      </ul>
            </td>
            <td valign="Top" width="71%">
      <dl>
      <dd>ODBC/CLI works as a state machine. The state                 information
 is a five character string that                 identifies the current state.</dd>
        </dl>
            </td>
        </tr>
        <tr>
            <td valign="Top" width="29%">
        <ul>

          <li>Native code&nbsp;</li>

        </ul>
            </td>
            <td valign="Top" width="71%">
        <dl>
        <dd>Integer code which is the native database error    code. Codes
from an Oracle driver are different                 from codes  from a PostgreSQL
driver.</dd>
          </dl>
            </td>
        </tr>
        <tr>
            <td valign="Top" width="29%">
          <ul>

            <li>Diagnostic&nbsp;</li>

          </ul>
            </td>
            <td valign="Top" width="71%">
          <dl>
          <dd>String that "explains" what happened.                 Beware
 : with some drivers this message can be                 empty, even if an
 error occurred.</dd>
            </dl>
            </td>
        </tr>


      </table>

      <p>A basic error handling routine would look like this
 : </p>

 <div id="code">
 <pre>

 handle_error (status : ECLI_STATUS) is
 	do
 		if status.<b>has_information_message</b> or status.<b>is_error</b> then
 			print (status.<b>cli_state</b>)
 			print (status.<b>native_code</b>)
 			print (status.<b>diagnostic_message</b>)
 		end
 	end

 </pre>
 </div>

      <p>ECLI_STATUS features introduced so far :  </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Queries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>is_ok</i></td>
            <td valign="Top" width="71%">is there no error ?</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>has_information_message</i></td>
            <td valign="Top" width="71%">there is no error, but an  information
message is available</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>is_error</i></td>
            <td valign="Top" width="71%">is there an error ?</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>cli_state</i></td>
            <td valign="Top" width="71%">5-character string- ODBC/CLI
 state code</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>native_code</i></td>
            <td valign="Top" width="71%">integer status code, from  the native
underlying library</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>diagnostic_message</i></td>
            <td valign="Top" width="71%">string that represent the  driver's
error diagnostic message</td>
        </tr>


      </table>
    </center>
         </div>

      <p>The classes ECLI_SESSION and ECLI_STATEMENT (see next chapter) inherit
 from ECLI_STATUS, and can be used the same way. </p>

      <h1><a name="StatementExec"></a>
   Statement execution</h1>

      <p>Execution of a SQL request is done through an ECLI_STATEMENT object.
 The ECLI_STATEMENT class provides all the features needed to execute SQL
requests and get the associated results. </p>

      <p align="Left">The next example shows the execution of 2 types of SQL
queries : (1) Data Definition Language (DDL) used for table creation or structure
modification, and (2) Data Manipulation Language (DML) used for selection,
insertion, and update of table content. <br>
    &nbsp; </p>

<div id="code">
<pre>
stmt : ECLI_STATEMENT

...

create stmt.<strong>make</strong> (session)
-- DDL statement
stmt.<b>set_sql</b> ("CREATE TABLE ECLIESSAI ( %
	% name CHAR(20), fname VARCHAR (20), nbr INTEGER,%
	% bdate DATETIME, price FLOAT)")

stmt.<b>execute</b>
if stmt.is_ok then
	io.put_string ("Table ECLIESSAI created%N")
else
	handle_error (stmt)
end

-- DML statements
stmt.<b>set_sql</b> ("INSERT INTO ECLIESSAI VALUES %
	% ('Toto', 'Henri', 10, {ts '2000-05-24 08:20:15.00'}, 33.3)")
stmt.<b>execute</b>

...

stmt.<strong>close</strong>
</pre>


</div>

      <p>The first query creates a table whose name is 'ECLIESSAI'. The second
 one shows an insertion, where actual values are provided as constants. ODBC/CLI
 introduces a standard notation to express constant values for specific types
 like dates ( <b>{d 'yyyy-mm-dd'}</b> ) and timestamps ( <b>{ts 'yyyy-mm-dd
 hh:mm:ss.cc'}</b> ). </p>

      <p>As you can notice, the same statement object has been used to execute
 two different queries. When you are finished with one query, <i>set_sql</i>
    allows you to change the query and go further with statement execution.
       </p>

      <p align="Center">The ECLI_STATEMENT features introduced so far are
 : &nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Commands</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td><em>make, open</em></td>
            <td>make, open the statement</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>set_sql</i></td>
            <td valign="Top" width="71%">set SQL string to execute</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>execute</i></td>
            <td valign="Top" width="71%">execute sql string</td>
        </tr>
        <tr>
            <td><em>close</em></td>
            <td>close the statement. It is not related anymore to the
 session on which it was open</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><b>Qeries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>sql</i></td>
            <td valign="Top" width="71%">current sql string</td>
        </tr>


      </table>
    </center>
         </div>

      <h1><a name="GettingResults"></a>
   Getting results</h1>

      <p>A database selection returns a virtual table known as a <i>result-set</i>
   . This is an actual table since it also can be queried. A result-set can
 be explored by opening a cursor that provides access to each row in turn.
 A row is a set (tuple) of values whose characteristics (type, name) correspond
 to the selected table columns. </p>

      <p>A database driver needs some specific storage to transfer data to
 and from the database. This storage is <i>typed</i>, i.e. it must correspond
 to a database-specific datatype. </p>

      <p>Let us first speak about those data types before actually getting
 results. </p>

      <h2>About database data types</h2>

      <p>Databases have their own datatypes. They slightly differ from one
 database to another; they also are different from the basic Eiffel classes.
 The ODBC/CLI supports the SQL92 standardized datatypes. ECLI only supports
 the most common data types. This could be easily extended in the future.</p>

      <p><i>*NOTE* : SQL92 datatypes are not supported by all database vendors.
 &nbsp;Oracle for example does not support VARCHAR (n) or LONGVARCHAR (n)
, instead, one must use VARCHAR2 (n)</i><i> provided that &nbsp;1 &lt;= n
&lt;= 2000. &nbsp;</i><i><br>
         </i><i>For the moment, ECLI does </i><i><b>not</b></i><i> shield
users  from database idiosyncrasies.</i><i><br>
         </i> </p>

      <p>Low-level data transfer is done using database-oriented values that
 are directly used by the driver as a buffer. A conversion is or can be necessary
 between the driver's buffers and Eiffel objects. </p>

      <p>ECLI clearly separates objects that are used for data transfer from
 the ones that are used by the application. The data-transfer objects inherit
 from class ECLI_VALUE. Those classes provide transfer-specific features while
 giving access to a preferred (default) Eiffel class. </p>

      <p align="Left">The ECLI_VALUE classes closely model the ECLI-supported
 SQL92 data values, they also provide what we call a 'preferred' (default?)
 Eiffel object. &nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="33%"><b>ECLI</b> </td>
            <td valign="Top" width="33%"><b>SQL92</b> </td>
            <td valign="Top" width="33%"><b>preferred Eiffel<br>
 item type<br>
             </b> </td>
             <td valign="Top"><b>Access</b><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_CHAR</td>
            <td valign="Top" width="33%">CHAR (n); 1 &lt;= n &lt; 255</td>
            <td valign="Top" width="33%">STRING</td>
             <td valign="Top"><i>to_string</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_VARCHAR</td>
            <td valign="Top" width="33%">VARCHAR (n); 1 &lt;= n &lt;    255</td>
            <td valign="Top" width="33%">STRING</td>
             <td valign="Top"><i>to_string</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_INTEGER</td>
            <td valign="Top" width="33%">INTEGER</td>
            <td valign="Top" width="33%">INTEGER_REF</td>
             <td valign="Top"><i>to_integer</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_FLOAT</td>
            <td valign="Top" width="33%">FLOAT</td>
            <td valign="Top" width="33%">DOUBLE_REF</td>
             <td valign="Top"><i>to_double</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_DOUBLE</td>
            <td valign="Top" width="33%">DOUBLE</td>
            <td valign="Top" width="33%">DOUBLE_REF</td>
             <td valign="Top"><i>to_double</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_REAL</td>
            <td valign="Top" width="33%">REAL</td>
            <td valign="Top" width="33%">REAL_REF</td>
             <td valign="Top"><i>to_real</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_DATE</td>
            <td valign="Top" width="33%">DATE</td>
            <td valign="Top" width="33%">DT_DATE (Gobo)</td>
             <td valign="Top"><i>to_date</i><br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_TIMESTAMP</td>
            <td valign="Top" width="33%">TIMESTAMP</td>
            <td valign="Top" width="33%">DT_DATE_TIME (Gobo)</td>
             <td valign="Top"><i>to_timestamp</i><br>
             </td>
        </tr>
        <tr>
            <td>ECLI_TIME</td>
            <td>TIME</td>
            <td>DT_TIME (Gobo)</td>
             <td valign="Top">Not yet implemented<br>
             </td>
        </tr>
        <tr>
            <td valign="Top" width="33%">ECLI_LONGVARCHAR</td>
            <td valign="Top" width="33%">LONGVARCHAR</td>
            <td valign="Top" width="33%">STRING</td>
             <td valign="Top"><i>to_string</i><br>
             </td>
        </tr>


      </table>
    </center>
         </div>

      <p>The originality of this model is to allow for database NULL value
 detection. While other database libraries provide default Eiffel values for
 a NULL database value, ECLI allows reading or writing such a NULL value.
      </p>

      <p align="Left">The important ECLI_VALUE features are :&nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="50%"><b>Commands</b> </td>
            <td valign="Top" width="50%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>set_null</i></td>
            <td valign="Top" width="50%">set value to NULL. There is    no
Eiffel object correspondance.</td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><b>Queries</b> </td>
            <td valign="Top" width="50%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>is_null</i></td>
            <td valign="Top" width="50%">is this a NULL database
value  ?</td>
        </tr>
        <tr>
            <td valign="Top" width="50%"><i>item</i></td>
            <td valign="Top" width="50%">gives access to the         preferred
 Eiffel object correspondance. &nbsp;It is void if <i>is_null = True</i>.<br>
             </td>
        </tr>
           <tr>
             <td valign="Top"><i>to_string, to_integer, to_double, to_date,
to_timestamp, to_real</i><br>
             </td>
             <td valign="Top">equivalent of<br>

            <ul>

              <li>&nbsp;<small>
 item </small>if preferred type is a reference.</li>

              <li>&nbsp;<small>
 item.item</small> if preferred type is expanded.</li>

            </ul>
             </td>
           </tr>
           <tr>
             <td valign="Top"><i>convertible_to_string, convertible_to_double,
convertible_to_real, convertible_to_timestamp, convertible_to_date, convertible_to_integer</i><br>
             </td>
             <td valign="Top">True when <small>
 item </small>is of that type.<br>
             </td>
           </tr>


      </table>
    </center>
         </div>

      <h2>Scanning a result-set</h2>

      <p>Using ODBC/CLI, the execution of a SELECT statement implicitly opens
 a cursor on the result-set. Before reading individual results, data-transfer
 objects have to be provided. The <i>set_cursor</i> feature provides an array
 of ECLI_VALUE objects to an ECLI_STATEMENT. After that, results can be fetched,
 one row (array of values) at a time. </p>

      <p align="Left">ECLI_STATEMENT sweeps through the result-set as if it
were a linear collection (features <i>start</i>, <i>forth</i>, <i>off</i>
   ).&nbsp; </p>

 <div id="code">
 <pre>
vname  :	 ECLI_CHAR
vprice :	 ECLI_DOUBLE
vbdate :	 ECLI_TIMESTAMP
vfname :	 ECLI_VARCHAR
vnbr   : 	 ECLI_INTEGER
-- selection of tuples
stmt.set_sql ("SELECT * FROM ECLIESSAI")
stmt.execute
-- get results
if stmt.is_ok and then stmt.<b>has_results</b> then
	 -- create result set 'value holders'
	 create vname.make (20)
	 create vnbr.make
	 create vprice.make
	 create vfname.make (20)
	 create vbdate.make_first
	 -- define the container of value holders
	 stmt.<b>set_cursor</b> (&lt;&lt;vname, vfname, vnbr, vbdate, vprice&gt;&gt;)
	 -- iterate on result-set
	 from
		&nbsp; stmt.<b>start</b>
		show_column_names (stmt)
	 until
		stmt.<b>off</b>
	loop
		show_result_row (stmt)
		stmt.<b>forth</b>
	end
end
</pre>
 </div>

      <p align="Left">ECLI_STATEMENT features related to getting results :
&nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Commands</b> </td>
            <td valign="Top" width="71%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>start</i></td>
            <td valign="Top" width="71%">position cursor to first row</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>forth</i></td>
            <td valign="Top" width="71%">advance cursor forth</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>set_cursor</i></td>
            <td valign="Top" width="71%">set array of value objects   to
be used as cursor storage</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><b>Queries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>off</i></td>
            <td valign="Top" width="71%">is cursor off any valid
position  (either 'before' or 'after') ?</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>has_results</i></td>
            <td valign="Top" width="71%">does the last SQL execution    lead
to a result-set (even empty) ? True for selection         queries or stored
procedures. False for updates and         insertions.</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>cursor</i></td>
            <td valign="Top" width="71%">array of current result
objects</td>
        </tr>


      </table>
    </center>
         </div>

      <h1><a name="Getting result-setmetadata"></a>
   Getting result-set metadata</h1>

      <p align="Left">It is often interesting to get a <i>description</i>
    of a result-set, known as metadata. The following example shows how it
is possible to get the names of the resulting rows&nbsp;:&nbsp; </p>

<div id="code">
<pre>
show_column_names (stmt : ECLI_STATEMENT) is
	local
		i, width : INTEGER
		s : STRING
	do
		stmt.<b>describe_cursor</b>
		from
			i := 1
	 	until
			i &gt; stmt.<b>cursor_description</b>.count
		loop
			width := stmt.cursor_description.item (i).<em>column_precision</em>
			create s.make (width)
			s.append (stmt.cursor_description.item (i).<em>name</em>)
			-- pad with blanks
			from
				width := width - s.count
			until
				width &lt;= 0
			loop
			 	s.append_character (' ')
				width := width - 1
			end
			io.put_string (s)
			if i &lt;= stmt.cursor_description.count then
				 io.put_character ('|')
			end
			i := i + 1
		end
		io.put_character ('%N')
	end
	</pre>
</div>

      <p>The feature <i>describe_cursor</i> of ECLI_STATEMENT produces an
 array, <i>cursor_description</i>, of objects. These objects are of type ECLI_COLUMN_DESCRIPTION.
       </p>

      <p align="Left">ECLI_STATEMENT features related to result-set metadata
 are :</p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Commands</b> </td>
            <td valign="Top" width="71%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>describe_cursor</i></td>
            <td valign="Top" width="71%">get metadata about current   result-set.</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><b>Queries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>cursor_description</i></td>
            <td valign="Top" width="71%">array of         ECLI_COLUMN_DESCRIPTION
 objects, describing the current         cursor columns.</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>result_column_count</i></td>
            <td valign="Top" width="71%">number of columns in the result-set.
 The size of the array passed by <i>set_cursor</i>         is checked against
 this value.</td>
        </tr>


      </table>
    </center>
         </div>
     <br>
        <br>

      <h1><a name="Stored_procedures"></a>
  Stored procedures</h1>
  Stored procedures can be called using a ODBC/CLI neutral syntax. &nbsp;Please
check first that your RDBMS is capable of using stored procedures.<br>
        <br>
  Stored procedures cannot be defined in a portable way. &nbsp;Each RDBMS
has its own syntax. &nbsp;DDL for stored procedures is not addressed by ECLI
(nor by CLI/ODBC).<br>
        <br>
  Let <em>my_procedure</em>
   be the procedure name, it can be called this way<br><br>

<div id="code">
<pre>
statement.set_sql ("{call my_procedure}")
statement.execute
</pre>
</div>

<br>
A procedure with parameters can be called this way<br><br>

<div id="code">
<pre>statement.set_sql ("{call my_other_procedure (33,&nbsp;'HectoPascal')}")
statement.execute
</pre>
</div>
      <h1><a name="Transactions"></a>
   Transactions</h1>
   Transactions are "atomic" sequences of database actions. &nbsp;A transaction
 is either executed, or not.<br>
         <br>
   Transactions are important when updating a database. &nbsp;For example,
deleting an order must delete all order lines. &nbsp;If any of the order
lines cannot be deleted, then nothing is deleted. &nbsp;The order and its
corresponding order lines are members of the transactions.<br>
         <br>
   A transaction is started at the session level, i.e. an ECLI_SESSION.<br>
         <br>
   Databases that do not support transactions exist. &nbsp;That is why it's
 possible to test if the session is transaction capable.<br>
         <br>
   ECLI does not support <i>nested</i> transactions since it's not supported
 by CLI/ODBC.<br>
         <br>
   ECLI_SESSION features related to transactions are :<br>
         <br>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
               <td valign="Top" width="29%"><b>Commands</b></td>
               <td valign="Top" width="71%"><b>Description</b></td>
             </tr>
             <tr>
               <td valign="Top" width="29%"><i>begin_transaction</i></td>
               <td valign="Top" width="71%">begins a new transaction</td>
             </tr>
             <tr>
               <td valign="Top"><i>commit</i><br>
               </td>
               <td valign="Top">commits current transaction<br>
               </td>
             </tr>
             <tr>
               <td valign="Top"><i>rollback</i></td>
               <td valign="Top">rollbacks transaction. &nbsp;All changes
that  have occurend since the last begin transaction are forgotten.<br>
               </td>
             </tr>
             <tr>
               <td valign="Top" width="29%"><b>Queries</b></td>
               <td valign="Top" width="71%"><b>description</b></td>
             </tr>
             <tr>
               <td valign="Top" width="29%"><i>is_transaction_capable</i></td>
               <td valign="Top" width="71%">is this session capable of working
 with transactions ?</td>
             </tr>
             <tr>
               <td valign="Top" width="29%"><i>transaction_capability</i></td>
               <td valign="Top" width="71%">Integer that denotes the actual
 transaction capability of the session.<br>
               </td>
             </tr>


      </table>
         </center>
         </div>
         <br>
   ECLI_TRANSACTION_CAPABILITY_CONSTANTS is a companion class that gives
the  code values and meanings of the different transaction capabilities.<br>
         <br>

      <h1><a name="ParameterizedStmts"></a>
   Parameterized statements</h1>

      <p>It is common to use SQL queries that look the same, but with different
 constant values. An example of this is when inserting a lot of data in the
 same table. One can for example read a file with data, and use the same INSERT
 query, but with different <i>parameters</i>. </p>

      <p>A first solution would be to concatenate some query string template
 with parameter values. Those values should then be expressed as constants.
 This is error-prone. This is also not a solution when you want to insert
some binary data like sound or pictures. </p>

      <p>Parameterized statements are another solution. Parameter values are
passed before query execution. The SQL syntax for that is simple : prefix
 the parameter names with a question mark. NOTE : This is not standard ODBC/CLI.
 In ODBC/CLI, parameters are positional. In ECLI, they are named. </p>

      <p align="Left">An insert statement like this &nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="0" cellpadding="3" cellspacing="0">

             <tr>
            <td bgcolor="#ffff99">
            <pre>INSERT INTO ECLIESSAI VALUES&nbsp;<tt>&nbsp;<br></tt>&nbsp;&nbsp;&nbsp; ('Toto', 'Henri', 10, {ts '2000-05-24 08:20:15.00'}, 33.3)</pre>
            </td>
        </tr>


      </table>
    </center>
         </div>

      <p align="Left">can be parameterized like this &nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="0" cellpadding="3" cellspacing="0">

             <tr>
            <td bgcolor="#ffff99">
            <pre>INSERT INTO ECLIESSAI VALUES&nbsp;<br><tt>&nbsp;&nbsp;&nbsp; </tt>(<b>?firstname, ?lastname, ?number, ?bdate, ?price</b>)</pre>
            </td>
        </tr>


      </table>
    </center>
         </div>

      <p align="Left">Parameters are passed either by providing an array of
ECLI_VALUE objects, or individually by name.&nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="0" cellpadding="3" cellspacing="0">

             <tr>
            <td valign="Top" bgcolor="#ffff99">
            <pre>othername:	ECLI_CHAR<br>p_name  :		 ECLI_CHAR<br>p_price :	&nbsp;&nbsp;&nbsp; ECLI_DOUBLE<br>p_bdate :	&nbsp;&nbsp;&nbsp; ECLI_TIMESTAMP<br>p_fname :	&nbsp;&nbsp;&nbsp; ECLI_VARCHAR<br>p_nbr :		&nbsp; ECLI_INTEGER<br><tt>...<br>create&nbsp;</tt>p_<tt>name.make (20)<br>create&nbsp;</tt>p_<tt>nbr.make<br>create&nbsp;</tt>p_<tt>price.make<br>create&nbsp;</tt>p_<tt>fname.make (20)<br>create&nbsp;</tt>p_<tt>bdate.make_first<br></tt>-- parameterized insertion<br><tt>stmt.set_sql ("</tt>INSERT INTO ECLIESSAI VALUES %<br><tt>&nbsp;&nbsp; % </tt>(<b>?firstname</b>, <b>?lastname</b>, <b>?number</b>, <b>?bdate</b>, <b>?price</b>)<tt>")<br><br>-- (STEP 1) set parameters by array<br>stmt.</tt><b><tt>set_parameters</tt></b><tt> (&lt;&lt;</tt>p_<tt>fname,&nbsp;</tt>p_<tt>name,&nbsp;</tt>p_<tt>nbr,&nbsp;</tt>p_<tt>bdate,&nbsp;</tt>p_<tt>price&gt;&gt;)<br><br>-- set values<br></tt>p_<tt>name.set_item ("Henry")<br></tt>p_<tt>fname.set_item ("Black")<br></tt>p_<tt>price.set_item (125.8)<br></tt>p_<tt>number.set_item (5)<br></tt>p_<tt>bdate.set_date (1995, 8, 19)<br><br>-- (STEP 2) bind them<br>stmt.</tt><b><tt>bind_parameters<br></tt></b><tt>-- (STEP 3) execute statement<br>stmt.execute<br>-- inserted tuple ("Henry", "Black", 5, {ts '1995-08-19 00:00:00'}, 125.8)<br><br>-- test execution status<br>if stmt.is_ok then<br>&nbsp;&nbsp;&nbsp; print ("Tuple inserted")<br>else<br>&nbsp;&nbsp;&nbsp; handle_error (stmt)<br>end<br><br>-- (STEP 4) set parameter by name<br>--&nbsp; a new value object is provided = parameters must be bound again<br>create othername.make (20); other_name.set_item ("Jim")<br>stmt.</tt><b><tt>put_parameter</tt></b><tt> (</tt>other<tt>name, "firstname")<br>stmt.</tt><b><tt>bind_parameters<br></tt></b><tt>stmt.execute<br>-- inserted tuple ("Jim", "Black", 5, {ts '1995-08-19 00:00:00.00'}, 125.8)<br><br>-- (STEP 5) change parameter object state = binding still apply<br>othername.set_item ("Louis")<br>stmt.execute<br>-- inserted tuple ("Louis", "Black", 5, {ts '1995-08-19 00:00:00.00'}, 125.8)<br>...</tt></pre>
            </td>
        </tr>


      </table>
    </center>
         </div>

      <ul>

        <li>Step 1 : parameters objects are passed in an array - set_parameters</li>

        <li>Step 2 : Parameters must be bound.&nbsp; This way, they    are
considered by the underlying driver as transfer         buffers from  the
application to the database.</li>

        <li>Step 3 : Statement is executed</li>

        <li>Step 4 : A new parameter object is passed by name.&nbsp;
i.e : this object replaces the "firstname"         parameter (rank 1) in
the parameters array.&nbsp; The         parameters must then be bound again
so that the         underlying driver can get advised of this modification.</li>

        <li>Step 5 : Changing the value contained by a parameter (through
feature set_item), updates the transfer buffer         content for the associated
parameter.&nbsp; The next         execution shall take this new value into
account.&nbsp;         Parameters need not be bound again.</li>

      </ul>

      <p align="Left">ECLI_STATEMENT features introduced so far : &nbsp;
     </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Commands</b> </td>
            <td valign="Top" width="71%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>set_parameters</i></td>
            <td valign="Top" width="71%">Set array of parameters. <br>
Parameters must then be bound so that they are used at execution.</td>
        </tr>
        <tr>
            <td width="29%"><i>put_parameter</i></td>
            <td width="71%">Put parameter object, by name. <br>
Parameters must then be bound so that they are used at execution.</td>
        </tr>
        <tr>
            <td width="29%"><i>bind_parameters</i></td>
            <td width="71%">Bind parameters to statement so that the    next
execution takes them into account</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><b>Queries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>bound_parameters</i></td>
            <td valign="Top" width="71%">True when parameters have  been
bound.</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>parameters</i></td>
            <td valign="Top" width="71%">array of current parameter   objects.</td>
        </tr>


      </table>
      <br>
      <br>
      </center>
      <div align="Left">
      <h1>
      <center></center>
      <a name="Tracing_"></a>
Tracing</h1>
When your application goes wrong, it is desirable to determine "what is wrong".
&nbsp;Is it the application logic ? &nbsp;Is it the SQL ?<br>
When your application is slow : is it related to the application logic, or
is it related to accessing data ?<br>
      <br>
Tracing issued SQL statements can help a lot in this respect.<br>
      <br>
Tracing occurs at the ECLI_SESSION level. &nbsp;You have to provide an instance
of ECLI_TRACER, that takes care of the tracing process.<br>
      <br>
ECLI_SESSION features related to tracing :<br>
      <br>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

          <tr>
            <td valign="Top" width="29%"><b>Commands</b></td>
            <td valign="Top" width="71%"><b>Description</b></td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><i>set_tracer</i></td>
            <td valign="Top" width="71%">Sets the instance of ECLI_TRACER
used for tracing.</td>
          </tr>
          <tr>
            <td width="29%"><i>disable_tracing</i></td>
            <td width="71%">Disable tracing. &nbsp;Previous tracer reference
is lost.<br>
            </td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><b>Queries</b></td>
            <td valign="Top" width="71%"><b>description</b></td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><i>is_tracing</i></td>
            <td valign="Top" width="71%">True when the session has a tracer
object.</td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><i>tracer</i></td>
            <td valign="Top" width="71%">Current tracer object</td>
          </tr>

      </table>
      <br>
ECLI_TRACER features :<br>
      <br>
      <table width="80%" border="1" cellpadding="5" cellspacing="0">

          <tr>
            <td valign="Top" width="29%"><b>Commands</b></td>
            <td valign="Top" width="71%"><b>Description</b></td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><i>make</i></td>
            <td valign="Top" width="71%">Creation feature. &nbsp;Needs an
IO_MEDIUM instance that <i>is_open_write</i>.</td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><b>Queries</b></td>
            <td valign="Top" width="71%"><b>description</b></td>
          </tr>
          <tr>
            <td valign="Top" width="29%"><i>medium</i></td>
            <td valign="Top" width="71%">Medium written by the tracer.<br>
            </td>
          </tr>

      </table>
      <br>
The trace file can be read and executed by the <i>isql</i> sample application.
&nbsp;For example, let <i>/tmp/trace.sql</i> be the tracefile; the batch
of SQL statements can be executed using this command : <i>isql &lt;datasource&gt;
&lt;username&gt; &lt;password&gt; /tmp/trace.sql</i>.<br>
      <br>
      <center>    </center>
         </div>
      </div>

      <h1><a name="OptimizingforPerformance"></a>
   Optimizing for "performance"</h1>

      <p>There are times when performance matters a lot.&nbsp; Optimizing
 performance can be done at the database level, and at the application level.
       </p>

      <h2>Use database indexes</h2>

      <p>At the database level, it is for example advised to define indexes
 on columns that are primary keys, search or sort keys. This can improve performance
 DRAMATICALLY. For example, in a heavy batch application, it has been possible
 to cut application time by 10, and database server time by 100 (hundred)
by creating an appropriate (selective enough) index! This performance improvement
 did not involve <em>any</em> code optimization.</p>

      <h2>Parameterize and prepare statements</h2>

      <p>At the application level, performance gains can be achieved by some
 actions :</p>

      <ul>

        <li><b>use parameterized statement</b>.&nbsp; The transfer   between
application memory and the database is         optimized.&nbsp; When using
an appropriate type, no         conversion is needed.&nbsp; When using constants
in the         query string, constants must be parsed and then converted
        from string to the appropriate type.</li>

        <li><b>prepare statements before execution</b>.&nbsp; A         database
 server executes a query in successive         steps.&nbsp; Statement preparation
 leads to an access         plan.&nbsp; Execution of a prepared statement
leads to         access plan execution only (step 5).&nbsp; Non-prepared
       statements involve the whole cycle (step 1 through 5),         each
time they are executed.</li>
      </ul>
      <ol>
        <li>Scan statement</li>
        <li>Validate statement</li>
        <li>Optimize</li>
        <li>Generate access plan</li>
        <li>Execute access plan</li>
      </ol>

      <p>As one can see, parameterized statement preparation can achieve dramatic
performance improvements if the same statement has to be executed many times
with different parameters. </p>

      <p>ECLI provides such features in ECLI_STATEMENT. </p>

      <p align="Left">Here is the last example, revisited.&nbsp; </p>

      <div align="Center">
      <center>
      <table width="80%" border="0" cellpadding="3" cellspacing="0">

             <tr>
            <td valign="Top" bgcolor="#ffff99">
            <pre>vname, othername :		 ECLI_CHAR<br>vprice :	&nbsp;&nbsp;&nbsp; ECLI_DOUBLE<br>vbdate :	&nbsp;&nbsp;&nbsp; ECLI_TIMESTAMP<br>vfname :	&nbsp;&nbsp;&nbsp; ECLI_VARCHAR<br>vnbr :		&nbsp; ECLI_INTEGER<br><tt>...<br>create vname.make (20)<br>create vnbr.make<br>create vprice.make<br>create vfname.make (20)<br>create vbdate.make_first<br></tt>-- parameterized insertion<br><tt>stmt.set_sql ("</tt>INSERT INTO ECLIESSAI VALUES %<br><tt>&nbsp;&nbsp; % </tt>(<b>?firstname</b>, <b>?lastname</b>, <b>?number</b>, <b>?bdate</b>, <b>?price</b>)<tt>")<br><br></tt><tt>-- </tt><b><tt>(STEP 0) statement preparation &lt;===========<br></tt></b><tt>stmt.</tt><b><tt>prepare<br><br></tt></b><tt>-- (STEP 1) set parameters by array<br>stmt.</tt><b><tt>set_parameters</tt></b><tt> (&lt;&lt;vname, vfname, vnbr, vbdate, vprice&gt;&gt;)<br><br>-- set values<br>...<br><br>-- (STEP 2) bind them<br>stmt.</tt><b><tt>bind_parameters<br></tt></b><tt>-- (STEP 3) execute statement<br>stmt.execute<br>-- inserted tuple ("Henry", "Black", 5, {ts '1995-08-19 00:00:00.00'}, 125.8)<br><br>...<br><br>-- (STEP 4) set parameter by name - other way to set a parameter<br>--&nbsp; a new value object is provided = parameters must be bound again<br>create othername.make (20); other_name.set_item ("Jim")<br>stmt.</tt><b><tt>put_parameter</tt></b><tt> (vname, "firstname")<br>stmt.</tt><b><tt>bind_parameters<br></tt></b><tt>stmt.execute<br>-- inserted tuple ("Jim", "Black", 5, {ts '1995-08-19 00:00:00.00'}, 125.8)<br><br>-- (STEP 5) change parameter object state = binding still apply<br>othername.set_item ("Louis")<br>stmt.execute<br>-- inserted tuple ("Louis", "Black", 5, {ts '1995-08-19 00:00:00.00'}, 125.8)<br>...</tt></pre>
            </td>
        </tr>


      </table>
    </center>
         </div>

      <p>The only difference is the addition of Step 0, where the statement
 is prepared. </p>

      <p>This prepares the statement, and enters&nbsp; 'prepared_execution_mode'
 ( <i>is_prepared_execution_mode</i> = True).&nbsp; The statement stays in
 this mode, unless the <i>set_immediate_execution_mode </i>is called. </p>

      <p align="Left">ECLI_STATEMENT features introduced so far : &nbsp;
     </p>

      <div align="Center">
      <center>
      <table width="80%" border="1" cellpadding="3" cellspacing="0">

             <tr>
            <td valign="Top" width="29%"><b>Commands</b> </td>
            <td valign="Top" width="71%"><b>Description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>prepare</i></td>
            <td valign="Top" width="71%">Prepare the associated sql   query,
automatically falling from <em>immediate</em> to <em>prepared</em>
     execution mode.</td>
        </tr>
        <tr>
            <td><i>set_prepared_execution_mode</i></td>
            <td>Manual transition to prepared execution mode.</td>
        </tr>
        <tr>
            <td><i>set_immediate_execution_mode</i></td>
            <td>Manual transition to immediate execution mode</td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><b>Queries</b> </td>
            <td valign="Top" width="71%"><b>description</b> </td>
        </tr>
        <tr>
            <td valign="Top" width="29%"><i>is_prepared_execution_mode</i></td>
            <td valign="Top" width="71%">True after <i>prepare</i>,   or
            <i>set_prepared_execution_mode.</i></td>
        </tr>


      </table>
    </center>
         </div>

      <h2>Garbage Collection of ECLI objects</h2>

      <p>ECLI objects are tightly associated with corresponding ODBC/CLI handles
and data-structures.&nbsp; Objects are arranged in a "uses-relationship" :
ECLI_ENVIRONMENT &lt;-&gt; ECLI_SESSION&lt;-&gt; ECLI_STATEMENT.</p>

      <p>ECLI_SESSION objects depend on ECLI_ENVIRONMENT (which is a singleton).
 The relationship is implicitely established by ECLI_SESSION.make or ECLI_SESSION.open.
 The relationship disappears by calling ECLI_SESSION.close</p>

      <p>ECLI_STATEMENT objects depend on their associated ECLI_SESSION. The
relationship is explicitely established by ECLI_STATEMENT.make or ECLI_STATEMENT.open.
 The relationship disappears by calling ECLI_STATEMENT.close.</p>

      <p>Garbage collection is allowed provided that the "slave" objects have
been disconnected from their "master" object (closed).</p>

      <p>At garbage-collection time an exception is raised if any slave object
 stay linked.</p>

      <h3>Open</h3>

      <p>When an ECLI_SESSION is created, it is automatically attached to
 the corresponding ECLI_ENVIRONMENT.&nbsp; This works also for an ECLI_STATEMENT
 with respect to its associated ECLI_SESSION. </p>

      <p>An ECLI object cannot be <em>opened</em> until it is <i>closed</i>
   . </p>

      <h3>Close</h3>

      <p>When you are done with an ECLI object, it is possible to close it.&nbsp;
 That is to say such an object (in 'closed' state) is ready for garbage collection.&nbsp;
 Such a closed object is not usable any more ... except when it is opened
again. &nbsp; </p>

      <h1><a name="Conclusion"></a>
   Conclusion</h1>

      <p>This tutorial has shown the most important features of ECLI. </p>

      <p>Other more advanced features can be found in the class interfaces,
 in the examples, and with the tool application <i>query_assistant</i>. </p>

      <p>For example, we did not speak about the class ECLI_VALUE_FACTORY
 that allows to compose a cursor array with the good ECLI_VALUE descendant
 objects. </p>

      <p>We also did not present <i>query_assistant</i>, a tool that generates
 classes, which encapsulate SQL queries. </p>

      <p>The aim of ECLI is to provide a simple but efficient Relational Database
access library for the entire Eiffel community. Give it a try. Report problems
and send suggestions. You are welcome. </p>

      </body>
      </html>
